// Code generated by moq; DO NOT EDIT
// github.com/matryer/moq

package identitytest

import (
	"context"
	"github.com/ONSdigital/dp-identity-api/schema"
	"sync"
	"time"
)

var (
	lockEncryptorMockCompareHashAndPassword sync.RWMutex
	lockEncryptorMockGenerateFromPassword   sync.RWMutex
)

// EncryptorMock is a mock implementation of Encryptor.
//
//     func TestSomethingThatUsesEncryptor(t *testing.T) {
//
//         // make and configure a mocked Encryptor
//         mockedEncryptor := &EncryptorMock{
//             CompareHashAndPasswordFunc: func(hashedPassword []byte, password []byte) error {
// 	               panic("TODO: mock out the CompareHashAndPassword method")
//             },
//             GenerateFromPasswordFunc: func(password []byte, cost int) ([]byte, error) {
// 	               panic("TODO: mock out the GenerateFromPassword method")
//             },
//         }
//
//         // TODO: use mockedEncryptor in code that requires Encryptor
//         //       and then make assertions.
//
//     }
type EncryptorMock struct {
	// CompareHashAndPasswordFunc mocks the CompareHashAndPassword method.
	CompareHashAndPasswordFunc func(hashedPassword []byte, password []byte) error

	// GenerateFromPasswordFunc mocks the GenerateFromPassword method.
	GenerateFromPasswordFunc func(password []byte, cost int) ([]byte, error)

	// calls tracks calls to the methods.
	calls struct {
		// CompareHashAndPassword holds details about calls to the CompareHashAndPassword method.
		CompareHashAndPassword []struct {
			// HashedPassword is the hashedPassword argument value.
			HashedPassword []byte
			// Password is the password argument value.
			Password []byte
		}
		// GenerateFromPassword holds details about calls to the GenerateFromPassword method.
		GenerateFromPassword []struct {
			// Password is the password argument value.
			Password []byte
			// Cost is the cost argument value.
			Cost int
		}
	}
}

// CompareHashAndPassword calls CompareHashAndPasswordFunc.
func (mock *EncryptorMock) CompareHashAndPassword(hashedPassword []byte, password []byte) error {
	if mock.CompareHashAndPasswordFunc == nil {
		panic("moq: EncryptorMock.CompareHashAndPasswordFunc is nil but Encryptor.CompareHashAndPassword was just called")
	}
	callInfo := struct {
		HashedPassword []byte
		Password       []byte
	}{
		HashedPassword: hashedPassword,
		Password:       password,
	}
	lockEncryptorMockCompareHashAndPassword.Lock()
	mock.calls.CompareHashAndPassword = append(mock.calls.CompareHashAndPassword, callInfo)
	lockEncryptorMockCompareHashAndPassword.Unlock()
	return mock.CompareHashAndPasswordFunc(hashedPassword, password)
}

// CompareHashAndPasswordCalls gets all the calls that were made to CompareHashAndPassword.
// Check the length with:
//     len(mockedEncryptor.CompareHashAndPasswordCalls())
func (mock *EncryptorMock) CompareHashAndPasswordCalls() []struct {
	HashedPassword []byte
	Password       []byte
} {
	var calls []struct {
		HashedPassword []byte
		Password       []byte
	}
	lockEncryptorMockCompareHashAndPassword.RLock()
	calls = mock.calls.CompareHashAndPassword
	lockEncryptorMockCompareHashAndPassword.RUnlock()
	return calls
}

// GenerateFromPassword calls GenerateFromPasswordFunc.
func (mock *EncryptorMock) GenerateFromPassword(password []byte, cost int) ([]byte, error) {
	if mock.GenerateFromPasswordFunc == nil {
		panic("moq: EncryptorMock.GenerateFromPasswordFunc is nil but Encryptor.GenerateFromPassword was just called")
	}
	callInfo := struct {
		Password []byte
		Cost     int
	}{
		Password: password,
		Cost:     cost,
	}
	lockEncryptorMockGenerateFromPassword.Lock()
	mock.calls.GenerateFromPassword = append(mock.calls.GenerateFromPassword, callInfo)
	lockEncryptorMockGenerateFromPassword.Unlock()
	return mock.GenerateFromPasswordFunc(password, cost)
}

// GenerateFromPasswordCalls gets all the calls that were made to GenerateFromPassword.
// Check the length with:
//     len(mockedEncryptor.GenerateFromPasswordCalls())
func (mock *EncryptorMock) GenerateFromPasswordCalls() []struct {
	Password []byte
	Cost     int
} {
	var calls []struct {
		Password []byte
		Cost     int
	}
	lockEncryptorMockGenerateFromPassword.RLock()
	calls = mock.calls.GenerateFromPassword
	lockEncryptorMockGenerateFromPassword.RUnlock()
	return calls
}

var (
	lockTokenServiceMockGet      sync.RWMutex
	lockTokenServiceMockNewToken sync.RWMutex
)

// TokenServiceMock is a mock implementation of TokenService.
//
//     func TestSomethingThatUsesTokenService(t *testing.T) {
//
//         // make and configure a mocked TokenService
//         mockedTokenService := &TokenServiceMock{
//             GetFunc: func(ctx context.Context, tokenStr string) (*schema.Identity, time.Duration, error) {
// 	               panic("TODO: mock out the Get method")
//             },
//             NewTokenFunc: func(ctx context.Context, identity schema.Identity) (*schema.Token, error) {
// 	               panic("TODO: mock out the NewToken method")
//             },
//         }
//
//         // TODO: use mockedTokenService in code that requires TokenService
//         //       and then make assertions.
//
//     }
type TokenServiceMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context, tokenStr string) (*schema.Identity, time.Duration, error)

	// NewTokenFunc mocks the NewToken method.
	NewTokenFunc func(ctx context.Context, identity schema.Identity) (*schema.Token, error)

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TokenStr is the tokenStr argument value.
			TokenStr string
		}
		// NewToken holds details about calls to the NewToken method.
		NewToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Identity is the identity argument value.
			Identity schema.Identity
		}
	}
}

// Get calls GetFunc.
func (mock *TokenServiceMock) Get(ctx context.Context, tokenStr string) (*schema.Identity, time.Duration, error) {
	if mock.GetFunc == nil {
		panic("moq: TokenServiceMock.GetFunc is nil but TokenService.Get was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		TokenStr string
	}{
		Ctx:      ctx,
		TokenStr: tokenStr,
	}
	lockTokenServiceMockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	lockTokenServiceMockGet.Unlock()
	return mock.GetFunc(ctx, tokenStr)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//     len(mockedTokenService.GetCalls())
func (mock *TokenServiceMock) GetCalls() []struct {
	Ctx      context.Context
	TokenStr string
} {
	var calls []struct {
		Ctx      context.Context
		TokenStr string
	}
	lockTokenServiceMockGet.RLock()
	calls = mock.calls.Get
	lockTokenServiceMockGet.RUnlock()
	return calls
}

// NewToken calls NewTokenFunc.
func (mock *TokenServiceMock) NewToken(ctx context.Context, identity schema.Identity) (*schema.Token, error) {
	if mock.NewTokenFunc == nil {
		panic("moq: TokenServiceMock.NewTokenFunc is nil but TokenService.NewToken was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Identity schema.Identity
	}{
		Ctx:      ctx,
		Identity: identity,
	}
	lockTokenServiceMockNewToken.Lock()
	mock.calls.NewToken = append(mock.calls.NewToken, callInfo)
	lockTokenServiceMockNewToken.Unlock()
	return mock.NewTokenFunc(ctx, identity)
}

// NewTokenCalls gets all the calls that were made to NewToken.
// Check the length with:
//     len(mockedTokenService.NewTokenCalls())
func (mock *TokenServiceMock) NewTokenCalls() []struct {
	Ctx      context.Context
	Identity schema.Identity
} {
	var calls []struct {
		Ctx      context.Context
		Identity schema.Identity
	}
	lockTokenServiceMockNewToken.RLock()
	calls = mock.calls.NewToken
	lockTokenServiceMockNewToken.RUnlock()
	return calls
}
