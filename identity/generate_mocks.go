// Code generated by moq; DO NOT EDIT
// github.com/matryer/moq

package identity

import (
	"github.com/ONSdigital/dp-identity-api/mongo"
	"sync"
)

var (
	lockPersistenceMockCreate      sync.RWMutex
	lockPersistenceMockGetIdentity sync.RWMutex
)

// PersistenceMock is a mock implementation of Persistence.
//
//     func TestSomethingThatUsesPersistence(t *testing.T) {
//
//         // make and configure a mocked Persistence
//         mockedPersistence := &PersistenceMock{
//             CreateFunc: func(newIdentity mongo.Identity) (string, error) {
// 	               panic("TODO: mock out the Create method")
//             },
//             GetIdentityFunc: func(email string) (mongo.Identity, error) {
// 	               panic("TODO: mock out the GetIdentity method")
//             },
//         }
//
//         // TODO: use mockedPersistence in code that requires Persistence
//         //       and then make assertions.
//
//     }
type PersistenceMock struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(newIdentity mongo.Identity) (string, error)

	// GetIdentityFunc mocks the GetIdentity method.
	GetIdentityFunc func(email string) (mongo.Identity, error)

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// NewIdentity is the newIdentity argument value.
			NewIdentity mongo.Identity
		}
		// GetIdentity holds details about calls to the GetIdentity method.
		GetIdentity []struct {
			// Email is the email argument value.
			Email string
		}
	}
}

// Create calls CreateFunc.
func (mock *PersistenceMock) Create(newIdentity mongo.Identity) (string, error) {
	if mock.CreateFunc == nil {
		panic("moq: PersistenceMock.CreateFunc is nil but Persistence.Create was just called")
	}
	callInfo := struct {
		NewIdentity mongo.Identity
	}{
		NewIdentity: newIdentity,
	}
	lockPersistenceMockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	lockPersistenceMockCreate.Unlock()
	return mock.CreateFunc(newIdentity)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//     len(mockedPersistence.CreateCalls())
func (mock *PersistenceMock) CreateCalls() []struct {
	NewIdentity mongo.Identity
} {
	var calls []struct {
		NewIdentity mongo.Identity
	}
	lockPersistenceMockCreate.RLock()
	calls = mock.calls.Create
	lockPersistenceMockCreate.RUnlock()
	return calls
}

// GetIdentity calls GetIdentityFunc.
func (mock *PersistenceMock) GetIdentity(email string) (mongo.Identity, error) {
	if mock.GetIdentityFunc == nil {
		panic("moq: PersistenceMock.GetIdentityFunc is nil but Persistence.GetIdentity was just called")
	}
	callInfo := struct {
		Email string
	}{
		Email: email,
	}
	lockPersistenceMockGetIdentity.Lock()
	mock.calls.GetIdentity = append(mock.calls.GetIdentity, callInfo)
	lockPersistenceMockGetIdentity.Unlock()
	return mock.GetIdentityFunc(email)
}

// GetIdentityCalls gets all the calls that were made to GetIdentity.
// Check the length with:
//     len(mockedPersistence.GetIdentityCalls())
func (mock *PersistenceMock) GetIdentityCalls() []struct {
	Email string
} {
	var calls []struct {
		Email string
	}
	lockPersistenceMockGetIdentity.RLock()
	calls = mock.calls.GetIdentity
	lockPersistenceMockGetIdentity.RUnlock()
	return calls
}

var (
	lockEncryptorMockCompareHashAndPassword sync.RWMutex
	lockEncryptorMockGenerateFromPassword   sync.RWMutex
)

// EncryptorMock is a mock implementation of Encryptor.
//
//     func TestSomethingThatUsesEncryptor(t *testing.T) {
//
//         // make and configure a mocked Encryptor
//         mockedEncryptor := &EncryptorMock{
//             CompareHashAndPasswordFunc: func(hashedPassword []byte, password []byte) error {
// 	               panic("TODO: mock out the CompareHashAndPassword method")
//             },
//             GenerateFromPasswordFunc: func(password []byte, cost int) ([]byte, error) {
// 	               panic("TODO: mock out the GenerateFromPassword method")
//             },
//         }
//
//         // TODO: use mockedEncryptor in code that requires Encryptor
//         //       and then make assertions.
//
//     }
type EncryptorMock struct {
	// CompareHashAndPasswordFunc mocks the CompareHashAndPassword method.
	CompareHashAndPasswordFunc func(hashedPassword []byte, password []byte) error

	// GenerateFromPasswordFunc mocks the GenerateFromPassword method.
	GenerateFromPasswordFunc func(password []byte, cost int) ([]byte, error)

	// calls tracks calls to the methods.
	calls struct {
		// CompareHashAndPassword holds details about calls to the CompareHashAndPassword method.
		CompareHashAndPassword []struct {
			// HashedPassword is the hashedPassword argument value.
			HashedPassword []byte
			// Password is the password argument value.
			Password []byte
		}
		// GenerateFromPassword holds details about calls to the GenerateFromPassword method.
		GenerateFromPassword []struct {
			// Password is the password argument value.
			Password []byte
			// Cost is the cost argument value.
			Cost int
		}
	}
}

// CompareHashAndPassword calls CompareHashAndPasswordFunc.
func (mock *EncryptorMock) CompareHashAndPassword(hashedPassword []byte, password []byte) error {
	if mock.CompareHashAndPasswordFunc == nil {
		panic("moq: EncryptorMock.CompareHashAndPasswordFunc is nil but Encryptor.CompareHashAndPassword was just called")
	}
	callInfo := struct {
		HashedPassword []byte
		Password       []byte
	}{
		HashedPassword: hashedPassword,
		Password:       password,
	}
	lockEncryptorMockCompareHashAndPassword.Lock()
	mock.calls.CompareHashAndPassword = append(mock.calls.CompareHashAndPassword, callInfo)
	lockEncryptorMockCompareHashAndPassword.Unlock()
	return mock.CompareHashAndPasswordFunc(hashedPassword, password)
}

// CompareHashAndPasswordCalls gets all the calls that were made to CompareHashAndPassword.
// Check the length with:
//     len(mockedEncryptor.CompareHashAndPasswordCalls())
func (mock *EncryptorMock) CompareHashAndPasswordCalls() []struct {
	HashedPassword []byte
	Password       []byte
} {
	var calls []struct {
		HashedPassword []byte
		Password       []byte
	}
	lockEncryptorMockCompareHashAndPassword.RLock()
	calls = mock.calls.CompareHashAndPassword
	lockEncryptorMockCompareHashAndPassword.RUnlock()
	return calls
}

// GenerateFromPassword calls GenerateFromPasswordFunc.
func (mock *EncryptorMock) GenerateFromPassword(password []byte, cost int) ([]byte, error) {
	if mock.GenerateFromPasswordFunc == nil {
		panic("moq: EncryptorMock.GenerateFromPasswordFunc is nil but Encryptor.GenerateFromPassword was just called")
	}
	callInfo := struct {
		Password []byte
		Cost     int
	}{
		Password: password,
		Cost:     cost,
	}
	lockEncryptorMockGenerateFromPassword.Lock()
	mock.calls.GenerateFromPassword = append(mock.calls.GenerateFromPassword, callInfo)
	lockEncryptorMockGenerateFromPassword.Unlock()
	return mock.GenerateFromPasswordFunc(password, cost)
}

// GenerateFromPasswordCalls gets all the calls that were made to GenerateFromPassword.
// Check the length with:
//     len(mockedEncryptor.GenerateFromPasswordCalls())
func (mock *EncryptorMock) GenerateFromPasswordCalls() []struct {
	Password []byte
	Cost     int
} {
	var calls []struct {
		Password []byte
		Cost     int
	}
	lockEncryptorMockGenerateFromPassword.RLock()
	calls = mock.calls.GenerateFromPassword
	lockEncryptorMockGenerateFromPassword.RUnlock()
	return calls
}
